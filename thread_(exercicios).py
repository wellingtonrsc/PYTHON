# -*- coding: utf-8 -*-
"""THREAD (EXERCICIOS)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uJfP4HKUHW1rrfRUx5uKNob6VMFXliI-

# **THREAD (EXERCICIOS)**

1- Crie uma função proc1 que imprime a mensagem "Processo 1" e siga as instruções:

a) Inicialize essa função a partir de um objeto thread t1

  b) Consulte se o objeto thread criado está ativo

  c) Consulte o nome da thread ativa atualmente

  d) Consulte o identificador de thead do thread atual

  e) Consulte a quantidade de threads ativas atualmente

  f) Retorne uma lista com todos os threads ativos atualmente
"""

from threading import Thread


# A) imprime a mensagem "Processo 1"
def proc1():
  for x in range(1):
    print("processo 1")    

t1 = Thread(target=proc1).start()

# B) indica a quantidade de threads ativas 
threading.active_count()

# C) identificando o nome da thread atual
import threading
import time
threading.currentThread()

# D) Consulta o indentificador da thread atual
threading.get_ident( )

# E) Consulta a quantidade de threads ativas atualmente
threading.enumerate( )

# F) Retorna uma lista com todos os threads ativos atualmente
threading

"""2. Crie duas funções, proc1 e proc2 que imprime a mensagem "Processo 1" e "Processo 2"
respectivamente e siga as instruções:

a) Inicialize as funções a partir de um objeto Thread t1 e t2 respectivamente

b) Consulte se os objetos criados estão ativos

c) Importe o modulo time e crie um delay de tempo em cada uma das funções, 
sendo sleep
5 e 30 segundos em proc1 e proc2 respectivamente

d) Consulte rapidamente (antes de 30 segundos) se cada um dos objetos thread está ativo
e imprima na tela
"""

# inicializando um thread

from threading import Thread
import time
import threading

def proc1():
    for x in range(1):
        print("Processo 1")
        time.sleep(5) #c

def proc2():
    for x in range(1):
        print("Processo 2 ")
        time.sleep(30) #c

t1 = Thread(target=proc1).start() #a
t2 = Thread(target=proc2).start() #a
threading.active_count() #b

"""**3. Responda as questões a seguir:**

**A) O que é o problema do produtor consumidor e como podemos resolver este problema com threads?**


Este problema também é conhecido como o problema do buﬀer limitado, e consiste
em coordenar o acesso de tarefas a um buﬀer compartilhado com capacidade de armazenamento limitada a N itens . São considerados dois tipos de processos com comportamentos simétricos:

**Produtor :** Cria e deposita um item no buﬀer, caso o mesmo tenha
uma vaga livre. Caso contrário, deve esperar até que surja uma vaga no buﬀer. Ao
depositar um item, o produtor “consome” uma vaga livre.

**Consumidor :** continuamente retira um item do buﬀer e o consome; caso o buﬀer esteja
vazio, aguarda que novos itens sejam depositados pelos produtores. Ao consumir
um item, o consumidor “produz” uma vaga livre.

Deve-se observar que o acesso ao buﬀer é bloqueante, ou seja, cada processo ﬁca
bloqueado até conseguir fazer seu acesso, seja para produzir ou para consumir um
item. 

A solução do problema dos produtores/consumidores envolve três aspectos de coor-
denação distintos:
• A exclusão mútua no acesso ao buﬀer, para evitar condições de disputa entre
produtores e/ou consumidores que poderiam corromper seu conteúdo.
• O bloqueio dos produtores no caso do buﬀer estar cheio: os produtores devem
aguardar até surjam vagas livres no buﬀer.
• O bloqueio dos consumidores no caso do buﬀer estar vazio: os consumidores
devem aguardar até surjam novos itens a consumir no buﬀer.

**B) Indique mais um problema clássico da computação e como podemos resolve-los com threads explicando de forma detalhada**

Outra situação que ocorre com freqüência em sistemas concorrentes é o problema dos leitores/escritores ou até mesmo uma planilha compartilhada no google que todos podem ler e alterar simultaneamente. Neste caso, um conjunto de processos ou threads acessam de forma concorrente uma área de memória comum (compartilhada), na qual podem fazer leituras ou escritas de valores. 

As leituras podem ser feitas simultaneamente, pois não interferem umas com as outras, mas as escritas têm de ser feitas com acesso exclusivo
à área compartilhada, para evitar condições de disputa.

Uma solução trivial para esse problema consistiria em proteger o acesso à área
compartilhada com um semáforo inicializado em 1; assim, somente um processo por
vez poderia acessar a área, garantindo a integridade de todas as operações.

"""